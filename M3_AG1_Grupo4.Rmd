---
title: 'M√ìDULO 3: Gesti√≥n de Datos y Datos Digitales'
author: 'Avalos Darwin & Trochez Alejandra '
date: "28 de Marzo del 2025"
output:
  html_document:
    df_print: paged
  word_document: null
subtitle: 'Pa√≠ses extremos en la implantaci√≥n de Facebook Alumno: 11 & Alumna:46'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
library(pander)
library(kableExtra)
library(readr)
library(tidyr)
library(stringr)
library(dplyr)
library(ggplot2)
library(DescTools) 
library(moments) 
library(stargazer)
library(tidyverse)
library(MASS)
library(modelsummary)
library(boot)

options(knitr.kable.NA = '')
```

# Descripci√≥n de la tarea

El objetivo de esta actividad consiste en analizar si hay pa√≠ses con niveles de implantaci√≥n de Facebook que presenten valores extremos. Para ello, se utilizar√°n los datos y modelos calculados en la actividad 2. Por otro lado, se analiza el valor faltante observado y se pide proponer un valor imputado.

Los datos a utilizar est√°n en la tabla fb_long.csv (ver descripcion de la actividad M3_AI4). Tambi√©n, se presupone que el fichero ya contiene la variable ‚ÄúFacebook_por_num‚Äù.  F:/Alumno-15/mbdds_fc20/R/Data_Managament/Data_Managament/fb_long.csv

Las tareas que te proponemos realizar son las siguientes:

# EJERCICIO 1
```{r}
df_fb <- read_delim(
  "C:/PERSONAL/Master IL3/mbdds_fc20/gestion_datos/www/fb_long.csv",
  delim = ";",
  locale = locale(decimal_mark = ",", grouping_mark = "."),
  show_col_types = FALSE  # Ocultar mensaje de especificaci√≥n
)

# Ver estructura del dataset
str(df_fb)
```
## TAREA 1.1.
Calcula la variable ‚ÄúFacebook_por_Internet‚Äù= ‚ÄúPorcentaje de usuarios de Facebook sobre el total de usuarios de internet‚Äù (para cada pa√≠s y a√±o). Presenta y comenta el summary de esta variable.


```{r}
# C√°lculo de Facebook_por_num como porcentaje (0-100)
df_fb <- df_fb %>%
  mutate(Facebook_por_num = round((Facebook_num / poblacion_num) * 100, 2))
head(df_fb)
```


```{r}
df_fb <- df_fb %>% 
  mutate(
    Facebook_por_num = (Facebook_num / poblacion_num) * 100,
    Facebook_por_Internet = (Facebook_por_num / Internet_por_num) * 100
  )

# Resumen estad√≠stico
summary(df_fb$Facebook_por_Internet)
```
En la variable Facebook_por_num - Porcentaje de usuarios de Facebook sobre el total de usuarios de internet se observa que presenta un dato faltante, resultado de la variable Internet_por_num que tiene un dato faltante (Facebook_por_num / Internet_por_num) * 100. Presenta un valor m√≠nimo de 0.026%, este valor indica que en alg√∫n pa√≠s solo ese porcentaje de los usuarios de internet est√°n en Facebook, esto podr√≠a reflejar una penetraci√≥n extremadamente baja de Facebook en ese pa√≠s que en este caso es China. Presenta un valor m√°ximo de 122.07%, este valor extremo sugiere que, en alg√∫n pa√≠s, el n√∫mero de usuarios de Facebook supera ampliamente el n√∫mero de usuarios de internet reportado. Presenta una mediana de 55.19%, la mediana es el valor central de la distribuci√≥n y representa que el 50% de los pa√≠ses tienen un porcentaje de usuarios de Facebook entre el 0.026% y el 55.19% . Esto implica que, en la mayor√≠a de los pa√≠ses, aproximadamente poco m√°s de la mitad de los usuarios de internet est√°n en Facebook. Presenta una media de 50.94%, esta es ligeramente menor que la mediana, lo que sugiere que la distribuci√≥n est√° sesgada hacia valores m√°s bajos. Es decir, hay algunos pa√≠ses con valores muy altos que arrastran la media hacia arriba, aunque la mayor√≠a de los pa√≠ses tienen valores m√°s cercanos a la mediana. El 25% de los pa√≠ses tienen un porcentaje de usuarios de Facebook respecto a los usuarios de internet menor o igual al 25.82%. El 75% de los pa√≠ses tienen un porcentaje de usuarios de Facebook respecto a los usuarios de internet menor o igual al 71.19% . 

```{r}
# Identificar celdas vac√≠as o inconsistentes
df_fb %>%
  filter(is.na(Facebook_por_Internet) | is.na(Internet_por_num) | is.na(poblacion_num))
```

```{r}
# Crear columna inc_001 y eliminar registros inconsistentes
df_fb <- df_fb %>%
  mutate(
    inc_001 = ifelse(Internet_por_num == 0, Internet_por_num, NA)
  ) %>%
  filter(Internet_por_num != 0)  # Elimina filas donde Internet_por_num era cero

# Verificar resultados
head(df_fb)
```


```{r}
# Identificar celdas vac√≠as o inconsistentes
df_fb %>%
  filter(is.na(Facebook_por_Internet) | is.na(Internet_por_num) | is.na(poblacion_num))
```  
```{r}
# Mostrar resumen de las variables
summary(df_fb)

```


## TAREA 1.2.
Dibuja y comenta, mediante el boxplot, si hay (o no) pa√≠ses outliers respecto a la variable Facebook_por_Internet.


```{r}
# Cargar librer√≠as necesarias
library(ggplot2)
library(dplyr)
library(moments) # Para calcular curtosis y asimetr√≠a

# Calcular estad√≠sticas por a√±o: mediana, media, desviaci√≥n est√°ndar, coeficiente de variaci√≥n, min, max, Q1, Q3, curtosis, asimetr√≠a
estadisticas <- df_fb %>%
  group_by(anyo) %>%
  summarise(
    Mediana = median(Facebook_por_Internet, na.rm = TRUE),
    Media = mean(Facebook_por_Internet, na.rm = TRUE),
    Desv_Estandar = sd(Facebook_por_Internet, na.rm = TRUE),
    Coef_Variacion = sd(Facebook_por_Internet, na.rm = TRUE) / mean(Facebook_por_Internet, na.rm = TRUE), # CV = SD / Mean
    Min = min(Facebook_por_Internet, na.rm = TRUE),
    Max = max(Facebook_por_Internet, na.rm = TRUE),
    Q1 = quantile(Facebook_por_Internet, 0.25, na.rm = TRUE),
    Q3 = quantile(Facebook_por_Internet, 0.75, na.rm = TRUE),
    Curtosis = kurtosis(Facebook_por_Internet, na.rm = TRUE),
    Asimetria = skewness(Facebook_por_Internet, na.rm = TRUE)
  )

# Mostrar estad√≠sticas
print(estadisticas)

# Crear boxplot con ggplot2
ggplot(df_fb, aes(x = as.factor(anyo), y = Facebook_por_Internet)) +
  geom_boxplot(fill = "skyblue", alpha = 0.7, outlier.color = "red") +
  theme_minimal() +
  labs(title = "Porcentaje de usuarios de Facebook sobre usuarios de internet (2010-2018)",
       x = "A√±o",
       y = "Porcentaje de usuarios") +
  geom_text(data = estadisticas, 
            aes(label = paste("Media:", round(Media, 3), 
                              "\nMediana:", round(Mediana, 3), 
                              "\nDesv. Est√°ndar:", round(Desv_Estandar, 3), 
                              "\nCoef. Variaci√≥n:", round(Coef_Variacion, 3), 
                              "\nM√≠nimo:", round(Min, 3), 
                              "\nM√°ximo:", round(Max, 3), 
                              "\nQ1:", round(Q1, 3), 
                              "\nQ3:", round(Q3, 3), 
                              "\nCurtosis:", round(Curtosis, 3), 
                              "\nAsimetr√≠a:", round(Asimetria, 3))),
            x = as.factor(unique(df_fb$anyo)), 
            y = max(df_fb$Facebook_por_Internet, na.rm = TRUE), 
            vjust = -0.5, hjust = 0.5, size = 3, color = "blue")
```
En el gr√°fico respecto a la variable Facebook_por_Internet para el a√±o 2010 no se observa puntos outliers, mientras que para el a√±o 2018 si se observan algunos pa√≠ses por debajo del l√≠mite inferior. Se generaron las medidas de las variables para tener m√°s comprensi√≥n de la variable frente a cada a√±o. 

## TAREA 1.3.
Ajusta, de nuevo, los modelos de la actividad 2 de Facebook_por_num sobre Internet_por_num separados por a√±o. Dibuja el primer plot (es decir, plot(modelo,1)) del modelo de regresi√≥n de cada a√±o. Comenta si observas pa√≠ses con valores outliers en 2010. ¬øY en 2018?
Consejo: antes de ajustar los modelos, introduce, en el rowname del data frame, la concatenaci√≥n del nombre, el pa√≠s y el a√±o.


```{r}

# Convertir el tibble a dataframe
df_fb <- as.data.frame(df_fb)

# Asignar nombres de fila
df_fb$nombre_pais_anyo <- paste(df_fb$pais_r, df_fb$anyo)
rownames(df_fb) <- df_fb$nombre_pais_anyo

# Crear una columna con la concatenaci√≥n de pa√≠s y a√±o en los rownames
df_fb$nombre_pais_anyo <- paste(df_fb$pais_r, df_fb$anyo)
rownames(df_fb) <- df_fb$nombre_pais_anyo

# Filtrar datos para 2010 y 2018
datos_2010 <- filter(df_fb, anyo == 2010)
datos_2018 <- filter(df_fb, anyo == 2018)

# Ajustar modelos de regresi√≥n lineal
modelo_lineal_2010 <- lm(Facebook_por_num ~ Internet_por_num, data = datos_2010)
modelo_lineal_2018 <- lm(Facebook_por_num ~ Internet_por_num, data = datos_2018)

# Resumen de los modelos
summary(modelo_lineal_2010)
summary(modelo_lineal_2018)

```

Se generaron nuevamente los modelos con el dataset actual para cada a√±o.

```{r}
# Gr√°ficos de residuos vs ajustados para 2010 y 2018
par(mfrow = c(1, 2)) # Para mostrar ambos gr√°ficos en una misma fila
plot(modelo_lineal_2010, which = 1, main = "Residuos vs Ajustados (2010)")
plot(modelo_lineal_2018, which = 1, main = "Residuos vs Ajustados (2018)")

```
En los gr√°ficos de residuos se observa para el a√±o 2010 algunos pa√≠ses m√°s alejados como Islandia que presenta un residuo muy alto y positivo, tambi√©n se observa que Korea Rep y Jap√≥n tienen residuos, aunque no tan grandes como Islandia. En el a√±o 2018, se observan los pa√≠ses China, Rusia y Ucrania, que aparecen por debajo de la l√≠nea de cero, con residuos negativos importantes. Estos puntos podr√≠an ser considerados outliers o, como m√≠nimo, observaciones con grandes residuos. 


## TAREA 1.4. ¬øCu√°l puede ser la causa de la presencia de estos outliers en 2010? ¬øY en 2018?

```{r}

# Calcular residuos estandarizados
residuos_estandarizados_2010 <- rstandard(modelo_lineal_2010)
residuos_estandarizados_2018 <- rstandard(modelo_lineal_2018)

# Crear un dataframe con los residuos estandarizados y los nombres de los pa√≠ses
resultados_residuos_2010 <- data.frame(
  pais = rownames(datos_2010),
  residuo_estandarizado = residuos_estandarizados_2010
)

resultados_residuos_2018 <- data.frame(
  pais = rownames(datos_2018),
  residuo_estandarizado = residuos_estandarizados_2018
)

# Mostrar pa√≠ses con residuos estandarizados > 2 o < -2
outliers_residuos_2010 <- resultados_residuos_2010[abs(resultados_residuos_2010$residuo_estandarizado) > 2, ]
outliers_residuos_2018 <- resultados_residuos_2018[abs(resultados_residuos_2018$residuo_estandarizado) > 2, ]

print(outliers_residuos_2010)
print(outliers_residuos_2018)
```

Los outliers pueden deberse a circunstancias √∫nicas de cada pa√≠s, reflejan diferencias significativas en el uso de Facebook en relaci√≥n con el acceso a internet, influenciadas por factores culturales, pol√≠ticos y tecnol√≥gicos.  

Realizamos una validaci√≥n de los posibles pa√≠ses con datos outliers con el an√°lisis de los residuos estandarizados donde identificamos para el a√±o 2010: Islandia Residuo estandarizado = 3.85, se puede beber a que es un pa√≠s peque√±o con una alta penetraci√≥n de internet y una poblaci√≥n muy conectada a redes sociales. Jap√≥n Residuo estandarizado = -2.69, tiene una alta penetraci√≥n de internet, pero el uso de facebook es relativamente bajo en comparaci√≥n con otras plataformas locales. Korea Residuo estandarizado= -2.56, es un l√≠der mundial en tecnolog√≠a y conectividad, pero el uso de Facebook no era tan predominante en 2010. Para el a√±o 2018 China Residuo estandarizado = -2.28, facebook est√° bloqueado en China debido a restricciones gubernamentales, en su lugar, se utilizan plataformas locales como WeChat, etc. Rusia Residuo estandarizado = -3.00, tiene una alta penetraci√≥n de internet, pero el uso de facebook es menor en comparaci√≥n con plataformas locales. Ucrania = Residuo estandarizado = -2.80, tiene una preferencia por redes sociales locales o regionales. Uzbekist√°n Residuo estandarizado = -2.09, tiene una penetraci√≥n de internet relativamente baja en comparaci√≥n con otros pa√≠ses, y el uso de facebook puede estar limitado por factores socioecon√≥micos. 

## TAREA 1.5.
A partir del plot 4 y 5 del modelo, comenta si los valores de D Cook indican la presencia de outliers con un impacto relevante (D Cook > 1), en el ajuste de la regresi√≥n.

```{r}
# Gr√°ficos de Distancia de Cook para 2010 y 2018
par(mfrow = c(1, 2)) # Para mostrar ambos gr√°ficos en una misma fila

# Gr√°fico 4: Distancia de Cook para 2010
plot(modelo_lineal_2010, which = 4, main = "Distancia de Cook (2010)")

# Gr√°fico 4: Distancia de Cook para 2018
plot(modelo_lineal_2018, which = 4, main = "Distancia de Cook (2018)")
```

De acuerdo con lo observado en los gr√°ficos, ning√∫n pa√≠s supera el umbral de ùê∑Cook > 1. Esto significa que no hay observaciones con un impacto lo suficientemente grande como para cambiar de forma dr√°stica los coeficientes de la regresi√≥n. Sin embargo, algunos pa√≠ses como Islandia en el a√±o 2010 y Ucrania en el a√±o 2018 muestran valores de Cook superiores al resto, lo que indica cierta influencia sobre el modelo, a pesar de no ser un outlier cr√≠tico. 


## EJERCICIO 1.6.
Ajusta, ahora, los mismos modelos que en el punto 3, utilizando la versi√≥n robusta rlm de la librer√≠a MASS (algoritmo de los M-Estimadores). Presenta la comparaci√≥n de los modelos lm y rlm mediante la funci√≥n stargazer y comenta si observas cambios relevantes en los coeficientes del modelo respecto al modelo lm (algoritmo de m√≠nimos cuadrados).

```{r}
# Soluci√≥n correcta
s <- c(TRUE, FALSE, NA)

# Verificar si hay alg√∫n valor NA
if (any(is.na(s))) {
  print("Hay valores NA")
}

# Verificar si todos los valores son NA
if (all(is.na(s))) {
  print("Todos los valores son NA")
}
```
```{r}
# Verificar valores NA en las columnas relevantes
if (any(is.na(datos_2010$Facebook_por_num)) || any(is.na(datos_2010$Internet_por_num))) {
  stop("Hay valores NA en los datos de 2010. Limpia los datos antes de continuar.")
}

# Ajustar el modelo robusto 2010
modelo_robusto_2010 <- MASS::rlm(Facebook_por_num ~ Internet_por_num, data = datos_2010)
# Modelo robusto 2018 
modelo_robusto_2018 <- rlm(Facebook_por_num ~ Internet_por_num, data = datos_2018)
```


```{r}
# Funci√≥n para verificar valores NA
verificar_na <- function(x) {
  if (any(is.na(x))) {
    return("Hay valores NA")
  } else {
    return("No hay valores NA")
  }
}

# Ejemplo de uso
resultado <- verificar_na(datos_2010$Facebook_por_num)
print(resultado)
```


```{r}
# Resumen de los modelos lm
summary(modelo_lineal_2010)
summary(modelo_lineal_2018)

# Resumen de los modelos rlm
summary(modelo_robusto_2010)
summary(modelo_robusto_2018)
```
No fue posible presentar la comparaci√≥n de los modelos lm y rlm mediante la funci√≥n stargazer, porque el modelo rlm no contiene todas las m√©tricas necesarias para hacer el cuadro comparativo.  Por esta raz√≥n mostramos una tabla comparativa de los coeficientes y pendiente de los modelos. 


```{r}
# Extraer coeficientes de los modelos
coef_lm_2010 <- coef(modelo_lineal_2010)
coef_rlm_2010 <- coef(modelo_robusto_2010)

coef_lm_2018 <- coef(modelo_lineal_2018)
coef_rlm_2018 <- coef(modelo_robusto_2018)

# Crear una tabla comparativa
tabla_comparativa <- data.frame(
  Modelo = c("LM 2010", "RLM 2010", "LM 2018", "RLM 2018"),
  Intercepto = c(coef_lm_2010[1], coef_rlm_2010[1], coef_lm_2018[1], coef_rlm_2018[1]),
  Pendiente = c(coef_lm_2010[2], coef_rlm_2010[2], coef_lm_2018[2], coef_rlm_2018[2])
)

print(tabla_comparativa)
```
Por lo cual se emplea modelsummary en lugar de stargazer para mayor flexibilidad con modelos robustos.

```{r}
library(modelsummary)
modelsummary(list(
  "LM 2010" = modelo_lineal_2010,
  "RLM 2010" = modelo_robusto_2010,
  "LM 2018" = modelo_lineal_2018,
  "RLM 2018" = modelo_robusto_2018
), fmt = 3)

```
Se observa para el 2010 que el intercepto del modelo rlm (-2.299 vs -1.972	[lm]) es ligeramente m√°s negativo, pero no hay diferencias sustanciales, esto implica que la relaci√≥n entre la penetraci√≥n de Internet y Facebook es similar en ambos modelos, lo que sugiere que los outliers en 2010 no tuvieron un impacto significativo en el modelo lineal. 

Respecto a las pendientes 2010 la pendiente del modelo rlm es pr√°cticamente id√©ntica a la del lm (0.446 | 0.439 [lm]), con un error est√°ndar ligeramente menor; en 2018 a pendiente del rlm es pr√°cticamente igual a la del lm (0.723 vs 0.720), con errores est√°ndar similares (0.083) | (0.084).En el 2018 se reduce la magnitud negativa del intercepto de (-3.920 a -3.055), acerc√°ndose m√°s a cero el modelo rlm corrige levemente el intercepto, pero la relaci√≥n entre las variables se mantiene estable lo que indica que los outliers en 2018 tampoco distorsionan dr√°sticamente el modelo lineal. 

En resumen, el modelo RLM aunque corrige levemente el intercepto en 2018, no hay cambios dr√°sticos en la pendiente ni en el ajuste global respecto al modelo LM, lo que sugiere que la relaci√≥n entre las variables. Se recomienda saber escoger de forma correcta entre estos 2 modelos, de acuerdo al enfoque del estudio para el caso al buscar minimizar el impacto de outliers y priorizar la robustez se escoge el rlm, a pesar de no reportar valores R2 como el lm que es m√°s interpretable. 



## TAREA 1.7.
Prop√≥n un valor imputado para el missing observado en Taiw√°n en la variable Internet_por_num a partir de los modelos analizados u otro modelo nuevo ajustado a tal efecto.


Se utilizo la mediana como m√©todo para sustituir missing faltante para el a√±o 2010, en este caso el dato de Taiw√°n al tener caracter√≠sticas espec√≠ficas teniendo en cuenta que la mediana global podr√≠a subestimar su valor, se calcula la mediana solo para pa√≠ses similares asi√°ticos para mayor precisi√≥n. No se utiliz√≥ la media porque es susceptible a la presencia de valores extremos,el valor imputado de 71.5% para Taiw√°n en 2010 se puede considerar aceptable dado que el valor real de 2018 es 88% ; se intent√≥ emplear el modelo lm pero nos genera un error en el c√≥digo. 


```{r}
# Filtrar datos para 2010 y eliminar valores inconsistentes
datos_2010 <- df_fb %>%
  filter(anyo == 2010 & Internet_por_num > 0)

# Calcular mediana global para 2010
mediana_internet_2010 <- median(datos_2010$Internet_por_num, na.rm = TRUE)

# Calcular mediana para pa√≠ses asi√°ticos en 2010
paises_asia_2010 <- datos_2010 %>%
  filter(pais_r %in% c("China", "Japan", "South Korea", "Hong Kong SAR, China", "Singapore"))

mediana_internet_asia_2010 <- median(paises_asia_2010$Internet_por_num, na.rm = TRUE)

# Mostrar resultados
print(paste("Imputaci√≥n usando MEDIANA global de 2010:", round(mediana_internet_2010, 2)))
print(paste("Imputaci√≥n usando MEDIANA de pa√≠ses asi√°ticos en 2010:", round(mediana_internet_asia_2010, 2)))

# Imputar el valor en el dataframe original
df_fb$Internet_por_num[df_fb$pais_r == "Taiwan" & df_fb$anyo == 2010] <- mediana_internet_asia_2010

# Verificar el resultado
df_fb %>% filter(pais_r == "Taiwan" & anyo == 2010)
```

## TAREA 1.8.
Explica de qu√© forma puede ayudar el uso del Bootstrap (muestreo aleatorio simple con reemplazo) al proceso de imputaci√≥n de valores faltantes como el que has propuesto en el punto anterior.

```{r}
library(boot)

# Ejemplo de Bootstrap para la mediana de pa√≠ses asi√°ticos
set.seed(123)
resultados_bootstrap <- boot(data = paises_asia_2010$Internet_por_num, 
                             statistic = function(data, i) median(data[i], na.rm = TRUE), 
                             R = 1000)
intervalo_confianza <- boot.ci(resultados_bootstrap, type = "perc")$percent[4:5]
print(paste("Intervalo de confianza Bootstrap (95%):", round(intervalo_confianza, 2)))

```

El uso del Bootstrap ayuda a mejorar la precisi√≥n  al considerar la variabilidad natural de los datos, sus ventajas son la robustez ante la presencia de outliers. 

La mediana de pa√≠ses asi√°ticos en 2010 (71.5%) podr√≠a subestimar el valor real de Taiw√°n, ya que pa√≠ses como China (con restricciones a Facebook) o Indonesia (con baja penetraci√≥n de internet en 2010) pueden distorsionar la mediana. El Bootstrap genera m√∫ltiples muestras aleatorias de los pa√≠ses asi√°ticos, excluyendo casos extremos en cada iteraci√≥n. Esto produce un intervalo m√°s realista: 71%‚Äì78.21%.
